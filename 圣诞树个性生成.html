<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture Christmas Card</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: "Times New Roman", serif; }
        #hint { position: fixed; bottom: 24px; width: 100%; text-align: center; font-family: Cinzel; letter-spacing: 2px; color: #f5e6b3; z-index: 10; text-shadow: 0 0 10px rgba(0,0,0,1); }
        #upload-container { position: fixed; left: 50%; bottom: 80px; transform: translateX(-50%); z-index: 20; background: rgba(245, 230, 179, 0.2); padding: 10px; border-radius: 8px; }
        #upload { color: #f5e6b3; font-family: Cinzel; }
        video { position: fixed; right: 12px; bottom: 12px; width: 120px; opacity: 0.3; border-radius: 8px; z-index: 5; border: 1px solid #f5e6b3; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
    </style>
</head>

<body>
<div id="hint">正在初始化 3D 场景...</div>
<div id="upload-container">
    <input id="upload" type="file" accept="image/*" />
</div>
<video id="video" autoplay playsinline></video>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { FilesetResolver, GestureRecognizer } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8";

/* ---------------- 基础配置 ---------------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 5, 20);
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 50);
camera.position.set(0, 2, 8);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// 灯光
scene.add(new THREE.AmbientLight(0xffffff, 0.8));

/* ---------------- 圣诞树生成 ---------------- */
const TREE_COUNT = 4000;
const treeGeo = new THREE.BufferGeometry();
const treePos = new Float32Array(TREE_COUNT * 3);
const treeCol = new Float32Array(TREE_COUNT * 3);

for (let i = 0; i < TREE_COUNT; i++) {
    const h = Math.random() * 5;
    const r = (1 - h / 5) * (Math.random() * 1.5);
    const a = Math.random() * Math.PI * 2;
    treePos[i*3] = Math.cos(a) * r;
    treePos[i*3+1] = h - 1; // 往下移一点
    treePos[i*3+2] = Math.sin(a) * r;
    const g = 0.5 + Math.random() * 0.5;
    treeCol.set([g*0.8, g, g*0.5], i*3);
}
treeGeo.setAttribute("position", new THREE.BufferAttribute(treePos, 3));
treeGeo.setAttribute("color", new THREE.BufferAttribute(treeCol, 3));
const treePoints = new THREE.Points(treeGeo, new THREE.PointsMaterial({ size: 0.03, vertexColors: true }));
scene.add(treePoints);

/* ---------------- 雪花系统 ---------------- */
const snowCount = 1000;
const snowGeo = new THREE.BufferGeometry();
const snowPos = new Float32Array(snowCount * 3);
for(let i=0; i<snowCount; i++) {
    snowPos[i*3] = (Math.random()-0.5)*15;
    snowPos[i*3+1] = Math.random()*15;
    snowPos[i*3+2] = (Math.random()-0.5)*15;
}
snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPos, 3));
const snowPoints = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.03 }));
scene.add(snowPoints);

/* ---------------- 图片粒子处理 ---------------- */
let photoParticles = null;
const upload = document.getElementById("upload");
upload.onchange = e => {
    const file = e.target.files[0];
    if(!file) return;
    const img = new Image();
    img.onload = () => {
        if(photoParticles) scene.remove(photoParticles);
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = 100; canvas.height = 100; // 降低分辨率保证流畅
        ctx.drawImage(img, 0, 0, 100, 100);
        const data = ctx.getImageData(0, 0, 100, 100).data;
        const pts = [], cols = [];
        for(let y=0; y<100; y++) {
            for(let x=0; x<100; x++) {
                const idx = (y*100 + x)*4;
                if(data[idx+3] > 128) { // 只采集非透明像素
                    pts.push((x/100-0.5)*3, (1-y/100)*3 + 1, 0);
                    cols.push(data[idx]/255, data[idx+1]/255, data[idx+2]/255);
                }
            }
        }
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(pts, 3));
        g.setAttribute("color", new THREE.Float32BufferAttribute(cols, 3));
        photoParticles = new THREE.Points(g, new THREE.PointsMaterial({ size: 0.05, vertexColors: true }));
        photoParticles.visible = false;
        scene.add(photoParticles);
        document.getElementById("hint").textContent = "图片已加载！试试对着镜头比『心』(Pinch)";
    };
    img.src = URL.createObjectURL(file);
};

/* ---------------- AI 初始化 ---------------- */
let recognizer;
async function initAI() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        document.getElementById("video").srcObject = stream;
        
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
        recognizer = await GestureRecognizer.createFromOptions(vision, {
            baseOptions: { modelAssetPath: "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/gesture_recognizer.task" },
            runningMode: "VIDEO"
        });
        document.getElementById("hint").textContent = "AI 已就绪！请上传图片后用手势控制";
    } catch (e) {
        document.getElementById("hint").textContent = "摄像头或 AI 加载失败";
        console.error(e);
    }
}

/* ---------------- 动画循环 ---------------- */
function animate() {
    requestAnimationFrame(animate);
    
    // 雪花飘落
    const positions = snowPoints.geometry.attributes.position.array;
    for(let i=1; i<positions.length; i+=3) {
        positions[i] -= 0.02;
        if(positions[i] < -2) positions[i] = 10;
    }
    snowPoints.geometry.attributes.position.needsUpdate = true;

    // AI 手势检测逻辑
    if (recognizer && video.currentTime !== lastTime) {
        const result = recognizer.recognizeForVideo(video, performance.now());
        if (result.gestures.length > 0) {
            const gesture = result.gestures[0][0].categoryName;
            if (photoParticles) {
                if (gesture === "Pinch") photoParticles.visible = true;
                if (gesture === "Open_Palm") photoParticles.visible = false;
            }
        }
    }
    
    renderer.render(scene, camera);
}

let lastTime = -1;
const video = document.getElementById("video");
animate(); // 立即启动渲染
initAI();  // 后台加载 AI

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
