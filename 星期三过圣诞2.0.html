<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gothic Cyber Xmas - Fixed & Optimized</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --pink: #FF007F; 
            --bg-dark: #050505;   /* æ·±é‚ƒé»‘ï¼Œè¡¬æ‰˜è¾‰å…‰ */
        }
        body { margin: 0; background: var(--bg); color: white; overflow: hidden; font-family: 'Cinzel', serif; }
        
        /* UI ç•Œé¢ */
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        h1 { color: var(--gold); letter-spacing: 4px; margin: 0; font-size: 1.5rem; text-shadow: 0 0 10px var(--gold); }
        .status { font-size: 0.8rem; color: var(--pink); margin-top: 8px; border: 1px solid var(--pink); display: inline-block; padding: 4px 12px; background: rgba(0,0,0,0.6); }
        
        /* æ§åˆ¶åŒº */
        #controls { position: absolute; bottom: 30px; left: 20px; z-index: 10; pointer-events: auto; }
        .btn { 
            background: rgba(0,0,0,0.8); border: 1px solid var(--gold); color: var(--gold); 
            padding: 12px 24px; cursor: pointer; font-family: 'Cinzel'; font-weight: bold; 
            transition: 0.3s; 
        }
        .btn:hover { background: var(--gold); color: black; box-shadow: 0 0 15px var(--gold); }
        
        /* æ‘„åƒå¤´é¢„è§ˆ */
        #cam-preview { 
            position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; 
            border: 1px solid var(--pink); transform: scaleX(-1); border-radius: 8px; 
            overflow: hidden; opacity: 0.8; box-shadow: 0 0 10px var(--pink);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* åŠ è½½åŠ¨ç”» */
        #loader { 
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: opacity 0.8s; 
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid #333; 
            border-top: 3px solid var(--gold); border-radius: 50%; 
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { color: var(--gold); letter-spacing: 3px; font-size: 0.9rem; }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div class="loading-text" id="load-text">INITIALIZING NEURAL ENGINE...</div>
</div>

<div id="ui-layer">
    <h1>GOTHIC XMAS</h1>
    <div class="status" id="status-text">SYSTEM: WAITING FOR AI</div>
</div>

<div id="controls">
    <input type="file" id="files" multiple accept="image/*" style="display:none">
    <button class="btn" onclick="document.getElementById('files').click()">+ UPLOAD MEMORIES</button>
    <div style="font-size:0.7rem; color:#888; margin-top:10px;">
        âœŠæ¡æ‹³(èšåˆ) | ğŸ–å¼ å¼€(æ•£è½) | ğŸ‘Œæåˆ(æ”¾å¤§)
    </div>
</div>

<div id="cam-preview"><video id="webcam" autoplay playsinline></video></div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "tween": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.esm.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import TWEEN from 'tween';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8';

// --- å…¨å±€å˜é‡ ---
let scene, camera, renderer, composer, handLandmarker, video;
let elements = [], photoNodes = [], snowSystem;
let currentState = 'TREE'; 
let camRotation = { x: 0, y: 0 };

// --- åˆå§‹åŒ–å…¥å£ ---
async function init() {
    // 1. åˆ›å»ºåœºæ™¯
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050103, 0.02); // é»‘è‰²é›¾æ°”

    // 2. ç›¸æœº
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 30);

    // 3. æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ antialias: false }); // å…³é—­æŠ—é”¯é½¿ä»¥æå‡æ€§èƒ½(Bloomä¼šå¤„ç†è¾¹ç¼˜)
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // 4. åæœŸç‰¹æ•ˆ (è¾‰å…‰)
    const renderScene = new RenderPass(scene, camera);
    // ä¿®æ”¹å‚æ•°ï¼šstrength(å¼ºåº¦)ä»1.3æåˆ°1.8, radius(åŠå¾„)ä»0.5æåˆ°0.6, threshold(é˜ˆå€¼)ä»0.85é™åˆ°0.7
    // è¿™æ ·ä¼šè®©æ›´å¤šç‰©ä½“äº§ç”Ÿæ›´å¼ºçƒˆçš„è¾‰å…‰ halo
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1, 0.6, 0.7);
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // 5. ç¯å…‰
    const ambient = new THREE.AmbientLight(0xffffff, 0.2); // ç¯å¢ƒå…‰è°ƒæš—
    scene.add(ambient);


    // ä¿®æ”¹ä¸ºï¼šé“¶è‰²å¼ºå…‰ (å†·ç™½åè“ï¼Œæ¨¡æ‹Ÿæ¶²æ€é‡‘å±æ„Ÿ)
    // é¢œè‰²æ”¹ä¸º 0xE0E0FF (ææµ…çš„é“¶è“è‰²)
    // å¼ºåº¦æé«˜åˆ° 8-10ï¼Œä»¥äº§ç”Ÿâ€œåˆºç©¿é»‘æš—â€çš„å¼ºå¯¹æ¯”æ•ˆæœ

    const silverLight = new THREE.PointLight(0xE0E0FF, 10, 80); 
    silverLight.position.set(15, 20, 15);
    scene.add(silverLight);

    // å…³é”®è¡¥å……ï¼šå¢åŠ ä¸€ä¸ªå¾®å¼±çš„â€œæš—éƒ¨è¡¥å…‰â€æˆ–è°ƒæ•´æ¸…é™¤é¢œè‰²ï¼Œå¢å¼ºé»‘è‰²çš„æ·±é‚ƒæ„Ÿ
    renderer.setClearColor(0x020202); // ç¡®ä¿èƒŒæ™¯æ¥è¿‘çº¯é»‘ï¼Œäº§ç”Ÿâ€œé“¶é»‘â€å¯¹æ¯”
   
    // è¾…å…‰ï¼šå†·ç™½è‰²å…‰ï¼Œå‹¾å‹’è¾¹ç¼˜ï¼Œæ›¿ä»£ä¹‹å‰çš„ç²‰å…‰
    const coldLight = new THREE.PointLight(0xF8F8FF, 3, 60);
    coldLight.position.set(-15, -10, 15);
    scene.add(coldLight);


    // 6. åˆ›å»ºç‰©ä½“ (æ›¿æ¢äº†ä¹‹å‰çš„ initEnvironment)
    createParticles();
    createSnow();


    // 7. åˆ›å»ºé“¶è‰²æœˆç‰™æ ‘å°–
function createMoonTop() {
    const moonShape = new THREE.Shape();
    // ç»˜åˆ¶æœˆç‰™è½®å»“
    moonShape.moveTo(0, 2);
    moonShape.absarc(0, 0, 2, Math.PI * 0.4, Math.PI * 1.6, true);
    moonShape.absarc(0.8, 0, 1.5, Math.PI * 1.4, Math.PI * 0.6, false);
    
    const geometry = new THREE.ExtrudeGeometry(moonShape, { depth: 0.2, bevelEnabled: true, bevelSize: 0.05 });
    const material = new THREE.MeshPhysicalMaterial({
        color: 0xE0E0FF,
        emissive: 0xE0E0FF,
        emissiveIntensity: 3.0, // æå¼ºå‘å…‰
        metalness: 1.0,
        roughness: 0.1
    });
    
    const moon = new THREE.Mesh(geometry, material);
    // æ”¾ç½®åœ¨æ ‘å°–ä½ç½®ï¼ˆå‡è®¾æ ‘é«˜ 25ï¼Œä¸­å¿ƒåœ¨ 0ï¼Œæ‰€ä»¥æ ‘å°–åœ¨ 13 å·¦å³ï¼‰
    moon.position.set(0, 14, 0); 
    moon.scale.set(0.6, 0.6, 0.6);
    scene.add(moon);
    return moon;
}
window.moonTop = createMoonTop(); // æŒ‚è½½åˆ°å…¨å±€ä»¥ä¾¿åŠ¨ç”»


    // 8. åˆ›å»ºç²‰è‰²èºæ—‹å…‰çº¿
function createSpiral() {
    const points = [];
    const radius = 10;
    const height = 28;
    const turns = 5; // ç»• 5 åœˆ
    
    for (let i = 0; i <= 200; i++) {
        const t = i / 200;
        const angle = t * Math.PI * 2 * turns;
        const r = (1 - t) * radius + 1.5; // ä»ä¸‹å¾€ä¸Šæ”¶ç¼©ï¼Œä½†æ¯”æ ‘ç¨å¾®å®½ä¸€ç‚¹
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        const y = t * height - 12;
        points.push(new THREE.Vector3(x, y, z));
    }
    
    const curve = new THREE.CatmullRomCurve3(points);
    const tubeGeo = new THREE.TubeGeometry(curve, 200, 0.08, 8, false);
    const tubeMat = new THREE.MeshBasicMaterial({ 
        color: 0xFF007F,
        transparent: true,
        opacity: 0.8
    });
    
    const spiral = new THREE.Mesh(tubeGeo, tubeMat);
    scene.add(spiral);
    return spiral;
}
window.spiralLine = createSpiral();


    // 9. å¯åŠ¨ AI (è€—æ—¶æ“ä½œ)
    await setupAI();

    // 10. ç§»é™¤ Loadingï¼Œå¼€å§‹å¾ªç¯
    window.addEventListener('resize', onResize);
    const loader = document.getElementById('loader');
    loader.style.opacity = '0';
    setTimeout(() => loader.remove(), 800);


    
    animate();
}

// --- åœºæ™¯æ„å»ºï¼šé“¶é»‘å“¥ç‰¹ç‰ˆ ---
function createParticles() {
    const PALETTE = {
        SILVER: 0xE0E0FF,      // é“¶è‰²å¼ºå…‰è‰²
        WHITE: 0xFFFFFF,       // é—ªçƒçº¯ç™½
        BLACK_GIFT: 0x050505,  // é’¢ç´é»‘ç¤¼ç›’
        DEEP_GOTHIC: 0x111111, // å“¥ç‰¹é»‘é’»
        PINK: 0xFF007F,        // éœ“è™¹ç²‰ç‚¹ç¼€
        DIM_GOLD: 0x8A732E     // å‰Šå‡åçš„é»¯æ·¡é‡‘è‰²ï¼ˆä½œä¸ºæå°‘é‡çš„ç‚¹ç¼€ï¼‰
    };

    // 1. å®šä¹‰å‡ ä½•ä½“
    const starGeo = new THREE.OctahedronGeometry(0.22, 1); 
    const ballGeo = new THREE.IcosahedronGeometry(0.15, 1); 
    const candyGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8); 
    const boxGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3); // é»‘è‰²ç¤¼ç›’å½¢çŠ¶

    // è°ƒæ•´æ¦‚ç‡åˆ†å¸ƒï¼šå¢åŠ é»‘è‰²å’Œé“¶è‰²ï¼Œæå°‘é‡é‡‘è‰²
    // é€»è¾‘ï¼š0-0.4 é»‘è‰²ç¤¼ç›’ï¼Œ0.4-0.7 é“¶é»‘ç²’å­ï¼Œ0.7-0.85 çº¯ç™½/é“¶ï¼Œ0.85-0.9 é»¯æ·¡é‡‘ï¼Œ0.9-1.0 ç²‰è‰²
    for(let i=0; i<1400; i++) {
        let geo, mat, color;
        const rand = Math.random();

        if (rand < 0.35) {
            // --- é»‘è‰²é’¢ç´æ¼†ç¤¼ç›’ (35% å æ¯”) ---
            geo = boxGeo;
            color = PALETTE.BLACK_GIFT;
            mat = new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 0.9,
                roughness: 0.02, // æå…‰æ»‘ï¼Œåå°„é“¶è‰²å¼ºå…‰
                clearcoat: 1.0,  // é’¢ç´æ¼†è´¨æ„Ÿ
                clearcoatRoughness: 0,
                reflectivity: 1.0
            });
        } else if (rand < 0.15) {
            // --- ç²‰è‰²ç³–æœ (ä¿æŒä¸å˜) ---
            geo = candyGeo;
            color = PALETTE.PINK;
            mat = new THREE.MeshPhysicalMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 4.0,
                metalness: 0.5,
                roughness: 0.1
            });
        } else {
            // --- å…¶å®ƒé‡‘å±ç²’å­ ---
            geo = Math.random() > 0.5 ? starGeo : ballGeo;
            
            // é¢œè‰²æƒé‡é‡æ–°åˆ†é…
            const subRand = Math.random();
            if (subRand < 0.6) color = PALETTE.DEEP_GOTHIC; // å¤§é‡é»‘é’»
            else if (subRand < 0.9) color = PALETTE.SILVER; // é“¶è‰²
            else color = PALETTE.DIM_GOLD;                  // æå°‘é‡æ—§é‡‘è‰²

            mat = new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 1.0,
                roughness: 0.05,
                clearcoat: 0.8,
                emissive: color,
                // é“¶è‰²å’Œç™½è‰²å‘å°„å¼ºè¾‰å…‰ï¼Œé»‘è‰²äº§ç”Ÿæ·±é‚ƒæ„Ÿ
                emissiveIntensity: (color === PALETTE.SILVER) ? 2.0 : 0.1
            });

            if (color === PALETTE.DEEP_GOTHIC) {
                mat.emissive.setHex(0x110022); // ææ·±ç´«è¾¹ç¼˜è‰²
            }
        }

        const mesh = new THREE.Mesh(geo, mat);
        
        // èµ‹äºˆéšæœºæ—‹è½¬ï¼Œè®©ç¤¼ç›’çš„åˆ‡é¢èƒ½æ•æ‰åˆ°ä¸åŒè§’åº¦çš„é“¶å…‰
        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        // è®¡ç®—æ ‘å½¢æ€ä½ç½® (åœ†é”¥èºæ—‹)
        const h = Math.random() * 25;
        const r = (1 - h/25) * 9;
        const theta = Math.random() * Math.PI * 2 * 12; 

        //è®¡ç®—æ•£å¼€ä½ç½® (éšæœºäº‘)
        mesh.userData.treePos = new THREE.Vector3(Math.cos(theta)*r, h-12, Math.sin(theta)*r);
        mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*50, (Math.random()-0.5)*50);

        mesh.position.copy(mesh.userData.treePos); // åˆå§‹çŠ¶æ€ï¼šæ ‘

        scene.add(mesh);
        elements.push(mesh);
    }
}

function createSnow() {
    const geo = new THREE.BufferGeometry();
    const pos = [];
    for(let i=0; i<2000; i++) {
        pos.push((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.6 });
    snowSystem = new THREE.Points(geo, mat);
    scene.add(snowSystem);
}

// --- ç…§ç‰‡ä¸Šä¼ å¤„ç† ---
document.getElementById('files').onchange = (e) => {
    const files = Array.from(e.target.files).slice(0, 5);
    // æ¸…é™¤æ—§ç…§ç‰‡
    photoNodes.forEach(n => scene.remove(n));
    photoNodes = [];
    
    files.forEach((file, i) => {
        new THREE.TextureLoader().load(URL.createObjectURL(file), (tex) => {
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 5.5), mat);
            
            // è®¾å®šä½ç½®
            mesh.userData.treePos = new THREE.Vector3(Math.cos(i)*6, i*3-5, Math.sin(i)*6);
            mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*20, 15);
            mesh.userData.type = 'photo';

            mesh.position.copy(mesh.userData.treePos);
            mesh.lookAt(0, mesh.position.y, 0); // æ ‘çŠ¶æ€ä¸‹æœå‘ä¸­å¿ƒ
            
            scene.add(mesh);
            photoNodes.push(mesh);
        });
    });
};

// --- AI åˆå§‹åŒ–ä¸æ‰‹åŠ¿ ---
async function setupAI() {
    try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
            runningMode: "VIDEO", 
            numHands: 1
        });
        
        video = document.getElementById('webcam');
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        
        // ç­‰å¾…è§†é¢‘æµå‡†å¤‡å¥½
        return new Promise((resolve) => {
            video.onloadeddata = () => {
                document.getElementById('status-text').innerText = "SYSTEM: READY";
                resolve();
            };
        });
    } catch(err) {
        document.getElementById('load-text').innerText = "AI ERROR: Check Console";
        console.error(err);
    }
}

// --- çŠ¶æ€åˆ‡æ¢æ ¸å¿ƒé€»è¾‘ ---
function switchState(newState) {
    if(currentState === newState && newState !== 'ZOOM') return;
    currentState = newState;
    
    // æ›´æ–° UI æ–‡å­—
    const label = { 'TREE': 'TREE MODE', 'SCATTER': 'CHAOS MODE', 'ZOOM': 'MEMORY LINK' };
    document.getElementById('status-text').innerText = "SYSTEM: " + label[newState];

    const allObjects = [...elements, ...photoNodes];
    
    allObjects.forEach(obj => {
        const isPhoto = obj.userData.type === 'photo';
        
        // 1. ç¡®å®šç›®æ ‡ä½ç½®
        let target = (newState === 'TREE') ? obj.userData.treePos : obj.userData.scatterPos;
        
        // ç‰¹æ®Šï¼šZoom æ¨¡å¼ä¸‹ï¼Œç…§ç‰‡é£åˆ°é¢å‰ï¼Œå…¶ä»–ç²’å­ä¿æŒæ•£å¼€
        if (newState === 'ZOOM' && isPhoto) {
            target = new THREE.Vector3(0, 0, 22); // é¢å‰
        } else if (newState === 'ZOOM' && !isPhoto) {
            target = obj.userData.scatterPos; // èƒŒæ™¯ä¿æŒæ•£å¼€
        }

        // 2. ä½ç½®è¡¥é—´åŠ¨ç”»
        new TWEEN.Tween(obj.position)
            .to({ x: target.x, y: target.y, z: target.z }, 1200)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();

        // 3. ç¼©æ”¾ä¸æ—‹è½¬ (ä»…é’ˆå¯¹ç…§ç‰‡)
        if (isPhoto) {
            const s = (newState === 'ZOOM') ? 1.5 : (newState === 'TREE' ? 0.5 : 1.0);
            new TWEEN.Tween(obj.scale).to({ x: s, y: s, z: s }, 1000).start();
            
            if (newState === 'ZOOM') {
                new TWEEN.Tween(obj.rotation).to({ x: 0, y: 0, z: 0 }, 1000).start();
            } else if (newState === 'TREE') {
                obj.lookAt(0, obj.position.y, 0); // é‡æ–°æœå‘ä¸­å¿ƒ
            }
        }
    });
}

// --- æ¸²æŸ“å¾ªç¯ ---
function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();

    if (window.moonTop) {
        // æœˆç‰™è‡ªè½¬
        window.moonTop.rotation.y += 0.02;
        // éšå‘¼å¸ç•¥å¾®ä¸Šä¸‹æµ®åŠ¨
        window.moonTop.position.y = 14 + Math.sin(Date.now() * 0.002) * 0.2;
}

    if (window.spiralLine) {
        // èºæ—‹çº¿ç»• Y è½´æ—‹è½¬
        window.spiralLine.rotation.y += 0.015;
    
        // åŠ¨æ€è°ƒæ•´é€æ˜åº¦ï¼Œäº§ç”Ÿé—ªçƒæ„Ÿ
        window.spiralLine.material.opacity = 0.5 + Math.sin(Date.now() * 0.005) * 0.3;
}

    // é›ªèŠ±ä¸‹è½
    if(snowSystem) {
        snowSystem.position.y -= 0.05;
        if(snowSystem.position.y < -40) snowSystem.position.y = 40;
    }

    // AI æ‰‹åŠ¿è¯†åˆ«
    if(handLandmarker && video.readyState >= 2) {
        const res = handLandmarker.detectForVideo(video, performance.now());
        if(res.landmarks && res.landmarks.length > 0) {
            const lm = res.landmarks[0];
            
            // ç®€å•æ‰‹åŠ¿é€»è¾‘
            const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y; // é£ŸæŒ‡ä¸­æŒ‡å¼¯æ›²
            const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[20].y < lm[18].y; // äº”æŒ‡å¼ å¼€
            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y); // æåˆè·ç¦»

            if (pinchDist < 0.05) switchState('ZOOM');
            else if (isOpen) switchState('SCATTER');
            else if (isFist) switchState('TREE');

            // æ—‹è½¬è§†è§’
            camRotation.x = (lm[9].x - 0.5) * -2; // å·¦å³
            camRotation.y = (lm[9].y - 0.5) * -1; // ä¸Šä¸‹
        }
    }

    // ç›¸æœºå¹³æ»‘è·Ÿéšæ‰‹åŠ¿
    camera.position.x += (Math.sin(camRotation.x)*30 - camera.position.x) * 0.05;
    camera.position.y += (5 + camRotation.y*10 - camera.position.y) * 0.05;
    camera.lookAt(0, 2, 0);

    composer.render();
}

function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

// å¯åŠ¨ç¨‹åº
init();
</script>
</body>
</html>