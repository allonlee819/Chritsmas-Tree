<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gothic Moon Xmas - Mobile Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --pink: #FF007F; --gold: #D4AF37; --bg: #020202; }
        body { margin: 0; background: var(--bg); color: white; overflow: hidden; font-family: 'Cinzel', serif; touch-action: none; }
        
        /* UI 适配手机 */
        #ui-layer { position: absolute; top: 15px; left: 15px; z-index: 10; pointer-events: none; }
        h1 { color: var(--gold); letter-spacing: 2px; margin: 0; font-size: 1.2rem; text-shadow: 0 0 10px var(--gold); }
        .status { font-size: 0.7rem; color: var(--pink); margin-top: 5px; border: 1px solid var(--pink); display: inline-block; padding: 2px 8px; background: rgba(0,0,0,0.6); }
        
        #controls { position: absolute; bottom: 25px; width: 100%; display: flex; justify-content: center; z-index: 10; }
        .btn { 
            background: rgba(0,0,0,0.85); border: 1px solid var(--gold); color: var(--gold); 
            padding: 15px 30px; cursor: pointer; font-family: 'Cinzel'; font-weight: bold; 
            border-radius: 30px; font-size: 0.9rem; box-shadow: 0 0 15px rgba(212,175,55,0.3);
        }

        #cam-preview { 
            position: absolute; top: 15px; right: 15px; width: 100px; height: 75px; 
            border: 1px solid var(--pink); transform: scaleX(-1); border-radius: 8px; 
            overflow: hidden; opacity: 0.7; z-index: 5;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        #loader { 
            position: fixed; inset: 0; background: #000; z-index: 100; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
        }
        .spinner { width: 40px; height: 40px; border: 3px solid #222; border-top: 3px solid var(--gold); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .hint { position: absolute; bottom: 80px; width: 100%; text-align: center; font-size: 0.6rem; color: #666; }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <div style="color:var(--gold); margin-top:20px; font-size:0.8rem;">LOADING GOTHIC UNIVERSE...</div>
</div>

<div id="ui-layer">
    <h1>GOTHIC MOON</h1>
    <div class="status" id="status-text">AI: INITIALIZING</div>
</div>

<div class="hint">TAP TO SWITCH MODE | HOLD TO UPLOAD</div>

<div id="controls">
    <input type="file" id="files" multiple accept="image/*" style="display:none">
    <button class="btn" onclick="document.getElementById('files').click()">UPLOAD MEMORIES</button>
</div>

<div id="cam-preview"><video id="webcam" autoplay playsinline></video></div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "tween": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.esm.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import TWEEN from 'tween';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8';

let scene, camera, renderer, composer, handLandmarker, video;
let elements = [], photoNodes = [], snowSystem;
let moonTop, spiralLine;
let currentState = 'TREE'; 
let camRotation = { x: 0, y: 0 };
let lastAIUpdateTime = 0;

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

async function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020202, 0.025);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 35);

    renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x020202);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.2);
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // 灯光设置
    const silverLight = new THREE.PointLight(0xE0E0FF, isMobile ? 8 : 12, 70);
    silverLight.position.set(15, 20, 15);
    scene.add(silverLight);
    scene.add(new THREE.AmbientLight(0x444466, 0.4));

    createParticles();
    createSnow();
    moonTop = createMoonTop();
    spiralLine = createSpiral();

    // 手机触摸交互备选
    renderer.domElement.addEventListener('pointerdown', handleTouch);

    await setupAI();

    window.addEventListener('resize', onResize);
    document.getElementById('loader').style.opacity = '0';
    setTimeout(() => document.getElementById('loader').remove(), 800);
    
    animate();
}

function createMoonTop() {
    const moonShape = new THREE.Shape();
    moonShape.moveTo(0, 2);
    moonShape.absarc(0, 0, 2, Math.PI * 0.4, Math.PI * 1.6, true);
    moonShape.absarc(0.8, 0, 1.5, Math.PI * 1.4, Math.PI * 0.6, false);
    
    const geometry = new THREE.ExtrudeGeometry(moonShape, { depth: 0.1, bevelEnabled: true, bevelSize: 0.05 });
    const material = new THREE.MeshPhysicalMaterial({
        color: 0xE0E0FF, emissive: 0xE0E0FF, emissiveIntensity: 3.0,
        metalness: 1.0, roughness: 0.1
    });
    
    const moon = new THREE.Mesh(geometry, material);
    moon.position.set(0, 13, 0); 
    moon.scale.set(0.5, 0.5, 0.5);
    scene.add(moon);
    return moon;
}

function createSpiral() {
    const points = [];
    const turns = 5;
    for (let i = 0; i <= 100; i++) {
        const t = i / 100;
        const angle = t * Math.PI * 2 * turns;
        const r = (1 - t) * 9 + 1.5;
        points.push(new THREE.Vector3(Math.cos(angle)*r, t*26 - 12, Math.sin(angle)*r));
    }
    const curve = new THREE.CatmullRomCurve3(points);
    const geometry = new THREE.TubeGeometry(curve, 100, 0.06, 8, false);
    const material = new THREE.MeshBasicMaterial({ color: 0xFF007F, transparent: true, opacity: 0.6 });
    const spiral = new THREE.Mesh(geometry, material);
    scene.add(spiral);
    return spiral;
}

function createParticles() {
    const PALETTE = { SILVER: 0xE0E0FF, BLACK: 0x050505, GOTHIC: 0x111111, PINK: 0xFF007F };
    const boxGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
    const starGeo = new THREE.OctahedronGeometry(0.2, 1);
    
    const count = isMobile ? 700 : 1400;

    for(let i=0; i<count; i++) {
        const rand = Math.random();
        let geo = rand < 0.4 ? boxGeo : starGeo;
        let color = rand < 0.5 ? PALETTE.BLACK : (rand < 0.8 ? PALETTE.GOTHIC : PALETTE.SILVER);
        
        const mat = new THREE.MeshPhysicalMaterial({
            color: color, metalness: 1.0, roughness: 0.05,
            clearcoat: 1.0, emissive: color,
            emissiveIntensity: color === PALETTE.SILVER ? 1.5 : 0.05
        });

        const mesh = new THREE.Mesh(geo, mat);
        const h = Math.random() * 24;
        const r = (1 - h/24) * 8.5;
        const theta = Math.random() * Math.PI * 2 * 10;
        
        mesh.userData.treePos = new THREE.Vector3(Math.cos(theta)*r, h-11, Math.sin(theta)*r);
        mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
        
        mesh.position.copy(mesh.userData.treePos);
        mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
        scene.add(mesh);
        elements.push(mesh);
    }
}

function createSnow() {
    const geo = new THREE.BufferGeometry();
    const pos = [];
    for(let i=0; i<(isMobile?800:2000); i++) pos.push((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.5 }));
    scene.add(snowSystem);
}

function handleTouch() {
    const states = ['TREE', 'SCATTER', 'ZOOM'];
    let nextIndex = (states.indexOf(currentState) + 1) % states.length;
    switchState(states[nextIndex]);
}

document.getElementById('files').onchange = (e) => {
    const files = Array.from(e.target.files).slice(0, 5);
    photoNodes.forEach(n => scene.remove(n));
    photoNodes = [];
    files.forEach((file, i) => {
        new THREE.TextureLoader().load(URL.createObjectURL(file), (tex) => {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(4, 5.5), new THREE.MeshBasicMaterial({ map: tex, side: 2 }));
            mesh.userData.treePos = new THREE.Vector3(Math.cos(i)*6, i*3-5, Math.sin(i)*6);
            mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*30, (Math.random()-0.5)*20, 15);
            mesh.userData.type = 'photo';
            mesh.position.copy(mesh.userData.treePos);
            scene.add(mesh);
            photoNodes.push(mesh);
        });
    });
};

async function setupAI() {
    try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
            runningMode: "VIDEO", numHands: 1
        });
        video = document.getElementById('webcam');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
        video.srcObject = stream;
        document.getElementById('status-text').innerText = "AI READY";
    } catch(err) {
        document.getElementById('status-text').innerText = "TAP TO PLAY (AI OFF)";
    }
}

function switchState(s) {
    if(currentState === s && s !== 'ZOOM') return;
    currentState = s;
    document.getElementById('status-text').innerText = "MODE: " + s;
    [...elements, ...photoNodes].forEach(obj => {
        let target = (s === 'TREE') ? obj.userData.treePos : obj.userData.scatterPos;
        if (s === 'ZOOM' && obj.userData.type === 'photo') target = new THREE.Vector3(0, 0, 22);
        new TWEEN.Tween(obj.position).to({ x: target.x, y: target.y, z: target.z }, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
    });
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();

    const time = performance.now();
    
    // 动画逻辑
    if (moonTop) moonTop.rotation.y += 0.01;
    if (spiralLine) spiralLine.rotation.y += 0.015;
    if (snowSystem) {
        snowSystem.position.y -= 0.03;
        if(snowSystem.position.y < -40) snowSystem.position.y = 40;
    }

    // AI 手势（限频检测）
    if(handLandmarker && video.readyState >= 2 && time - lastAIUpdateTime > 100) {
        const res = handLandmarker.detectForVideo(video, time);
        if(res.landmarks && res.landmarks.length > 0) {
            const lm = res.landmarks[0];
            const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y;
            const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y;
            const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);

            if (pinch < 0.06) switchState('ZOOM');
            else if (isOpen) switchState('SCATTER');
            else if (isFist) switchState('TREE');

            camRotation.x = (lm[9].x - 0.5) * -1.5;
            camRotation.y = (lm[9].y - 0.5) * -1;
        }
        lastAIUpdateTime = time;
    }

    camera.position.x += (Math.sin(camRotation.x)*25 - camera.position.x) * 0.05;
    camera.position.y += (5 + camRotation.y*8 - camera.position.y) * 0.05;
    camera.lookAt(0, 2, 0);

    composer.render();
}

function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

init();
</script>
</body>
</html>